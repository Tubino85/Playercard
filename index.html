<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Playercard • Roster & Rotazioni</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{ --bg:#0e0f11; --panel:#15171a; --muted:#9aa3ad; --text:#e9eef4; --acc:#5ac8fa;
      --card:#1b1e22; --line:#2a2f36; --soft:#24282e; --ok:#3ddc97; --warn:#ff9f1c; --danger:#ef476f; --radius:16px; }
    *{box-sizing:border-box}
    body{margin:0;background:#0d1015;color:var(--text);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
    header{position:sticky;top:0;z-index:5;background:#0f1319ee;backdrop-filter:blur(6px);border-bottom:1px solid #1d222b;padding:20px}
    h1{margin:0;font-size:20px}
    .wrap{max-width:1100px;margin:0 auto;padding:18px}
    .section{margin:18px 0 8px;font-size:18px}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin:10px 0}
    .btn{background:var(--acc);color:#031017;border:0;border-radius:10px;padding:9px 12px;font-weight:700;cursor:pointer}
    .btn.alt{background:#11151b;color:var(--text);border:1px solid var(--line)}
    .hint{color:var(--muted);font-size:12px}
    .grid{display:grid;gap:14px}
    .grid-2{grid-template-columns:repeat(2,1fr)} .grid-3{grid-template-columns:repeat(3,1fr)}
    .card{background:linear-gradient(180deg,var(--card),#161a1f);border:1px solid var(--line);border-radius:16px;padding:14px}
    label{display:block;color:#b9c3cf;font-size:12px;margin-bottom:6px}
    input,select{width:100%;background:#12161c;border:1px solid var(--line);color:var(--text);border-radius:10px;padding:9px 10px}
    input[disabled]{opacity:.9}
    table{width:100%;border-collapse:collapse;border:1px solid var(--line);border-radius:10px;overflow:hidden}
    th,td{padding:8px 10px;border-bottom:1px solid #222831;text-align:center}
    th{background:#12161c}
    .pill{display:inline-block;border:1px solid var(--line);background:#0f141b;color:#c8d2df;border-radius:999px;padding:3px 8px;font-size:11px}
    .k{background:var(--soft);border:1px solid #2b3038;border-radius:12px;padding:10px}
    .k b{display:block;font-size:12px;color:#9aa3ad;margin-bottom:6px}
    .posgrid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
    .poscell{background:#11161d;border:1px solid var(--line);border-radius:10px;padding:8px;text-align:center}
    .poscell b{display:block;font-size:11px;color:#9aa3ad}
    .msg{margin-top:8px;font-size:12px}
    .msg.warn{color:var(--warn)} .msg.err{color:var(--danger)}
    .invalid{outline:2px solid var(--danger)}
    @media (max-width:980px){ .grid-2,.grid-3,.posgrid{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <header><div class="wrap"><h1>Playercard • Roster & Rotazioni</h1></div></header>
  <div class="wrap">

    <div class="section">Dati giocatori</div>
    <div class="toolbar">
      <button id="reload" class="btn">Ricarica dati</button>
      <label class="btn alt">Carica JSON<input id="jsonFile" type="file" accept="application/json" hidden></label>
      <span class="hint">Se la pagina è su http/https e <code>players.json</code> è nella stessa cartella, si carica da solo.</span>
    </div>
    <div id="status" class="card"><span class="pill">Nessun database caricato</span></div>

    <div class="section">Roster (12)</div>
    <div id="roster" class="grid grid-2"></div>

    <div class="section">Rotazioni (R1–R6)</div>
    <div id="rotations" class="grid grid-3"></div>
    <div id="ruleMsg" class="msg"></div>

  </div>

 <script>
  // ===== Config / State =====
  const POSITIONS = ["FS","FC","FD","SLS","SLC","SLD"];
  const FRONT_POS = new Set(["FS","FC","FD"]);
  const ROSTER_SIZE = 12;
  let PLAYERS = {}; // mappa canonica: id -> {ID, Name, ATK, BLK, DEF, SET, SERV, Role?}

  // ===== Utils =====
  function normId(raw){
    if(raw==null) return "";
    const s = String(raw).trim().replace(/,/g,'.');
    const n = Number(s);
    if(!Number.isNaN(n)){ const i = Math.round(n); if(Math.abs(n-i)<1e-9) return String(i); return String(n); }
    return s;
  }
  function getPlayer(idRaw){
    const id = normId(idRaw);
    if(!id) return null;
    if(PLAYERS[id]) return PLAYERS[id];
    if(PLAYERS[id+".0"]) return PLAYERS[id+".0"];
    if(id.endsWith(".0") && PLAYERS[id.slice(0,-2)]) return PLAYERS[id.slice(0,-2)];
    return null;
  }
  function escapeHtml(s){ return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\"/g,"&quot;").replace(/'/g,"&#39;"); }
  function setStatus(msg, ok){
    const el = document.getElementById("status");
    el.innerHTML = '<span class="pill">'+(ok?'<b>OK</b> • ':'')+escapeHtml(msg)+'</span>';
  }
  function showRuleMsg(text, type="warn"){
    const el = document.getElementById("ruleMsg");
    el.className = "msg "+(type==="err"?"err":"warn");
    el.textContent = text || "";
  }
  function getQueryParam(name){
    const m = new RegExp('[?&]'+name+'=([^&#]*)').exec(location.search);
    return m ? decodeURIComponent(m[1].replace(/\+/g,' ')) : '';
  }
  // riconosce HTML
  function looksLikeHTML(txt){
    const t = String(txt).trim().slice(0,200).toLowerCase();
    return t.startsWith('<!doctype') || t.startsWith('<html') || t.includes('<head') || t.includes('<body');
  }
  // estrae JSON anche se è impacchettato in JS
  function smartParseMaybeJSON(txt){
    if (!txt) return null;
    if (txt.charCodeAt(0) === 0xFEFF) txt = txt.slice(1);
    let s = txt.trim();
    if (looksLikeHTML(s)) return null;
    try { return JSON.parse(s); } catch(e){}
    s = s.replace(/^(?:export\s+default\s+)?(?:const|var|let)\s+[A-Za-z0-9_$]+\s*=\s*/,'').trim();
    s = s.replace(/;\s*$/,'');
    const openObj = s.indexOf('{'); const openArr = s.indexOf('[');
    let start = -1; let end = -1;
    if (openObj !== -1 && (openArr === -1 || openObj < openArr)) { start = openObj; end = s.lastIndexOf('}'); }
    else if (openArr !== -1) { start = openArr; end = s.lastIndexOf(']'); }
    if (start >= 0 && end > start){
      const core = s.slice(start, end+1);
      try { return JSON.parse(core); } catch(e){}
    }
    return null;
  }

  // ===== Normalizzazione JSON (array o mappe) =====
  const ID_KEYS   = ["ID","Id","id","player_id","gid","code","codice","id_giocatore"];
  const NAME_KEYS = ["Name","name","Nome","Cognome","Giocatore","fullname","Fullname","full_name","fullName"];
  const ATK_KEYS  = ["ATK","atk","attack","attacco","deltaatt","delta_atk","DeltaATT"];
  const BLK_KEYS  = ["BLK","blk","block","blocco"];
  const DEF_KEYS  = ["DEF","def","defense","difesa"];
  const SET_KEYS  = ["SET","set","assist","palleggio"];
  const SRV_KEYS  = ["SERV","serv","serve","servizio"];
  const ROLE_KEYS = ["ROLE","Role","role","RUOLO","Ruolo","ruolo","POSITION","Position","position","POS","Pos","pos"];

  function pick(obj, keys){
    if (!obj) return undefined;
    for(const k of keys){ if (obj[k] != null) return obj[k]; }
    const map = {}; for (const kk in obj){ map[kk.toLowerCase()] = kk; }
    for(const k of keys){
      const low = String(k).toLowerCase();
      if (map[low] != null) return obj[map[low]];
    }
    return undefined;
  }
  function toNum(v){
    if (v == null || v === "") return 0;
    const n = Number(String(v).replace(',','.'));
    return Number.isFinite(n) ? n : 0;
  }
  function buildPlayersIndex(raw){
    const data = raw && (raw.playersById || raw);
    const map = {};
    function canonFrom(recLike){
      const idVal = pick(recLike, ID_KEYS);
      if (idVal == null || String(idVal).trim()==="") return null;
      const id = normId(idVal);
      return {
        ID: id,
        Name: String(pick(recLike, NAME_KEYS) ?? "").trim(),
        ATK: toNum(pick(recLike, ATK_KEYS)),
        BLK: toNum(pick(recLike, BLK_KEYS)),
        DEF: toNum(pick(recLike, DEF_KEYS)),
        SET: toNum(pick(recLike, SET_KEYS)),
        SERV: toNum(pick(recLike, SRV_KEYS)),
        Role: String(pick(recLike, ROLE_KEYS) ?? "").trim()
      };
    }
    if (Array.isArray(data)){
      for (const r of data){
        const canon = canonFrom(r);
        if (canon) map[canon.ID] = canon;
      }
    } else if (data && typeof data === "object"){
      for (const [maybeId, rec] of Object.entries(data)){
        const canon = canonFrom({ ...rec, ID: pick(rec, ID_KEYS) ?? maybeId });
        if (canon) map[canon.ID] = canon;
      }
    }
    return map;
  }

  // ===== Ruolo (se presente) =====
  function roleBlockedInFront(p){
    const s = (p && p.Role ? String(p.Role) : "").toUpperCase();
    return s === "R" || s === "L";
  }

  // ===== Data load (diagnostica + embedded) =====
  function getEmbeddedPlayers(){
    const tag = document.getElementById('players-embedded');
    if(!tag) return null;
    try { return JSON.parse(tag.textContent); }
    catch(e){ setStatus('Embedded JSON non valido: '+e.message, false); return null; }
  }

  async function loadDefault(){
    // 1) Fallback embedded (funziona anche in file://)
    const emb = getEmbeddedPlayers();
    if (emb){
      const idx = buildPlayersIndex(emb);
      if (Object.keys(idx).length){
        PLAYERS = idx;
        setStatus('Caricato embedded JSON ('+Object.keys(PLAYERS).length+' giocatori)', true);
        refreshAll();
        return;
      }
    }

    const tried = [];
    const candidates = [];
    const qp = getQueryParam('data'); if (qp) candidates.push(qp);
    candidates.push('players.json','players_with_role.json','players_1to1_from_excel.json');

    for (const path of candidates){
      const u = new URL(path, location.href);
      const bust = u.search ? '&v=' + Date.now() : '?v=' + Date.now();
      const url = u.href + bust;
      try{
        const r = await fetch(url, { cache: 'no-store' });
        tried.push(u.pathname + ' → ' + (r.status||'ERR'));
        if (!r.ok) continue;

        // 1) JSON diretto
        let idx = null, parsed = false;
        try{
          const raw = await r.clone().json();
          idx = buildPlayersIndex(raw);
          parsed = true;
        }catch(_){}

        // 2) Testo + smart parse (gestisce const data = {...}; ecc.)
        if (!parsed || !Object.keys(idx||{}).length){
          const txt = await r.text();
          if (looksLikeHTML(txt)){
            setStatus(`Attenzione: ${u.pathname} risponde 200 ma restituisce HTML (non JSON).`, false);
            continue;
          }
          const alt = smartParseMaybeJSON(txt);
          if (alt) idx = buildPlayersIndex(alt);
        }

        if (idx && Object.keys(idx).length){
          PLAYERS = idx;
          setStatus(`Caricato ${u.pathname} (${Object.keys(PLAYERS).length} giocatori)`, true);
          refreshAll();
          return;
        }
      }catch(e){
        tried.push(u.pathname + ' → ERR');
      }
    }

    setStatus(
      'Autoload fallito. Tentativi: ' + tried.join(' | ') +
      '. Verifica che l’URL restituisca JSON valido (non HTML). Puoi usare anche index.html?data=players.json oppure il pulsante "Carica JSON".',
      false
    );
  }

  function loadFromFile(file){
    const fr = new FileReader();
    fr.onload = ()=>{
      try{
        const raw = JSON.parse(fr.result);
        const idx = buildPlayersIndex(raw);
        if (!Object.keys(idx).length) {
          setStatus("JSON caricato ma non riconosco i campi (ID/fullname/ATK/BLK/DEF/SET/SERV).", false);
          return;
        }
        PLAYERS = idx;
        setStatus("Caricato JSON da file ("+Object.keys(PLAYERS).length+" giocatori)", true);
        refreshAll();
      }catch(e){
        setStatus("JSON non valido.", false);
      }
    };
    fr.readAsText(file);
  }

  // ===== Roster =====
  function stat(p,k){ return Number(p[k]) || 0; }
  function pname(p){ return p.Name || ""; }

  function buildRoster(){
    const root = document.getElementById("roster");
    root.innerHTML = "";
    for(let i=1;i<=ROSTER_SIZE;i++){
      const card = document.createElement("div");
      card.className = "card";
      card.innerHTML = `
        <div class="grid grid-2">
          <div>
            <label>ID</label>
            <input type="text" data-roster-id="${i}" placeholder="es. 1" />
          </div>
          <div>
            <label>Nome</label>
            <input type="text" data-roster-name="${i}" disabled />
          </div>
        </div>
        <div style="margin-top:10px">
          <table>
            <thead><tr><th>ATK</th><th>BLK</th><th>DEF</th><th>SET</th><th>SERV</th></tr></thead>
            <tbody><tr>
              <td data-roster-atk="${i}">—</td>
              <td data-roster-blk="${i}">—</td>
              <td data-roster-def="${i}">—</td>
              <td data-roster-set="${i}">—</td>
              <td data-roster-serv="${i}">—</td>
            </tr></tbody>
          </table>
        </div>`;
      root.appendChild(card);
    }
    for(let i=1;i<=ROSTER_SIZE;i++){
      const input = document.querySelector(`[data-roster-id="${i}"]`);
      input.addEventListener("input", ()=>{ fillRosterLine(i, input.value); refreshRotationOptions(); });
    }
  }
  function fillRosterLine(i, rawId){
    const p = getPlayer(rawId);
    const nameEl = document.querySelector(`[data-roster-name="${i}"]`);
    const t = {
      atk: document.querySelector(`[data-roster-atk="${i}"]`),
      blk: document.querySelector(`[data-roster-blk="${i}"]`),
      def: document.querySelector(`[data-roster-def="${i}"]`),
      set: document.querySelector(`[data-roster-set="${i}"]`),
      serv: document.querySelector(`[data-roster-serv="${i}"]`)
    };
    if(!p){
      nameEl.value = "";
      t.atk.textContent=t.blk.textContent=t.def.textContent=t.set.textContent=t.serv.textContent="—";
      return;
    }
    nameEl.value = pname(p);
    t.atk.textContent = stat(p,"ATK");
    t.blk.textContent = stat(p,"BLK");
    t.def.textContent = stat(p,"DEF");
    t.set.textContent = stat(p,"SET");
    t.serv.textContent = stat(p,"SERV");
  }
  function rosterEntries(){
    const ids = [];
    for(let i=1;i<=ROSTER_SIZE;i++){
      const v = document.querySelector(`[data-roster-id="${i}"]`).value;
      const p = getPlayer(v);
      if(p) ids.push({id:normId(v), name:pname(p)});
    }
    const seen = new Set();
    return ids.filter(x=>{ if(seen.has(x.id)) return false; seen.add(x.id); return true; });
  }

  // ===== Rotazioni =====
  function buildRotations(){
    const root = document.getElementById("rotations");
    root.innerHTML = "";
    for(let r=1;r<=6;r++){
      const c = document.createElement("div");
      c.className = "card";
      const selects =
        `<div class="posgrid">
           <div><label>FS</label><select data-rot="${r}-FS"><option value="">—</option></select></div>
           <div><label>FC</label><select data-rot="${r}-FC"><option value="">—</option></select></div>
           <div><label>FD</label><select data-rot="${r}-FD"><option value="">—</option></select></div>
           <div><label>SLS</label><select data-rot="${r}-SLS"><option value="">—</option></select></div>
           <div><label>SLC</label><select data-rot="${r}-SLC"><option value="">—</option></select></div>
           <div><label>SLD</label><select data-rot="${r}-SLD"><option value="">—</option></select></div>
         </div>`;
      let cellsA="", cellsB="";
      for(const pos of POSITIONS){
        cellsA += `<div class="poscell"><b>${pos}</b><span data-aks="${r}-${pos}">—/—</span></div>`;
        cellsB += `<div class="poscell"><b>${pos}</b><span data-bds="${r}-${pos}">—/—/—</span></div>`;
      }
      c.innerHTML = `
        <h3 style="margin:0 0 8px">Rotazione R${r} <span class="pill">R${r}</span></h3>
        ${selects}
        <div class="grid grid-2" style="margin-top:10px">
          <div class="k"><b>ATK/SET per posizione</b><div class="posgrid">${cellsA}</div></div>
          <div class="k"><b>BLK/DEF/SERV per posizione</b><div class="posgrid">${cellsB}</div></div>
        </div>`;
      root.appendChild(c);
    }
    for(let r=1;r<=6;r++){
      for(const pos of POSITIONS){
        const sel = document.querySelector(`[data-rot="${r}-${pos}"]`);
        sel.addEventListener("change", ()=>{
          const vals = POSITIONS.map(p=>document.querySelector(`[data-rot="${r}-${p}"]`).value).filter(Boolean);
          const count = vals.filter(v=>v===sel.value).length;
          if(count>1){ sel.value=""; showRuleMsg("ID già usato in R"+r+".", "warn"); }
          const pl = getPlayer(sel.value);
          if(FRONT_POS.has(pos) && pl && roleBlockedInFront(pl)){
            sel.value=""; showRuleMsg("Ruolo R/L non ammesso in FS/FC/FD.", "err");
            sel.classList.add("invalid"); setTimeout(()=>sel.classList.remove("invalid"),600);
          }
          enforceNoDuplicates(r);
          updateRotation(r);
        });
      }
    }
  }

  function buildOptionsForPos(entries, pos){
    return ['<option value="">—</option>'].concat(
      entries.map(e=>{
        const p = getPlayer(e.id);
        const rlBlocked = FRONT_POS.has(pos) && p && roleBlockedInFront(p);
        const dis = rlBlocked ? ' disabled title="Ruolo R/L non ammesso in FS/FC/FD"' : '';
        return `<option value="${e.id}"${dis}>[${e.id}] ${escapeHtml(e.name)}</option>`;
      })
    ).join("");
  }

  function refreshRotationOptions(){
    const entries = rosterEntries();
    for(let r=1;r<=6;r++){
      for(const pos of POSITIONS){
        const sel = document.querySelector(`[data-rot="${r}-${pos}"]`);
        const prev = sel.value;
        sel.innerHTML = buildOptionsForPos(entries, pos);
        const plPrev = getPlayer(prev);
        if(prev && entries.some(e=>e.id===prev) && !(FRONT_POS.has(pos) && plPrev && roleBlockedInFront(plPrev))){
          sel.value = prev;
        } else {
          sel.value = "";
        }
      }
      enforceNoDuplicates(r);
      updateRotation(r);
    }
  }

  function enforceNoDuplicates(r){
    const sels = POSITIONS.map(pos => document.querySelector(`[data-rot="${r}-${pos}"]`));
    const used = new Set(sels.map(s=>s.value).filter(Boolean));
    sels.forEach(sel=>{
      Array.from(sel.options).forEach(opt=>{
        if(!opt.value){ opt.disabled=false; return; }
        const isMine = sel.value === opt.value;
        const dupDisabled = used.has(opt.value) && !isMine;
        const pos = sel.getAttribute("data-rot").split("-")[1];
        const p = getPlayer(opt.value);
        const rlBlocked = FRONT_POS.has(pos) && p && roleBlockedInFront(p);
        opt.disabled = dupDisabled || rlBlocked;
      });
    });
  }

  function updateRotation(r){
    for(const pos of POSITIONS){
      const sel = document.querySelector(`[data-rot="${r}-${pos}"]`);
      const p = getPlayer(sel.value);
      const a = document.querySelector(`[data-aks="${r}-${pos}"]`);
      const b = document.querySelector(`[data-bds="${r}-${pos}"]`);
      if(!p){ a.textContent="—/—"; b.textContent="—/—/—"; continue; }
      a.textContent = `${Number(p.ATK)||0}/${Number(p.SET)||0}`;
      b.textContent = `${Number(p.BLK)||0}/${Number(p.DEF)||0}/${Number(p.SERV)||0}`;
    }
  }

  function refreshAll(){ buildRoster(); buildRotations(); refreshRotationOptions(); }

  // ===== Boot & events =====
  document.getElementById("reload").addEventListener("click", loadDefault);
  document.getElementById("jsonFile").addEventListener("change", e=>{
    const f = e.target.files && e.target.files[0]; if (f) loadFromFile(f);
  });
  loadDefault();
</script>
<script>
// --- [ADD] ordine di rotazione richiesto (diverso dall'ordine di visualizzazione) ---
const ROT_ORDER = ["FS","FC","FD","SLD","SLC","SLS"];

// --- [ADD] compila R2–R6 ruotando a partire da R1, con rispetto vincoli R/L ---
function autoFillFromR1(){
  // leggo la R1
  const src = {};
  for (const pos of ROT_ORDER){
    const sel = document.querySelector(`[data-rot="1-${pos}"]`);
    src[pos] = sel ? sel.value : "";
  }

  // applico shift k = r-1 per r=2..6
  for (let r = 2; r <= 6; r++){
    const k = (r - 1) % ROT_ORDER.length;
    for (let i = 0; i < ROT_ORDER.length; i++){
      const fromPos = ROT_ORDER[i];
      const destPos = ROT_ORDER[(i + k) % ROT_ORDER.length];
      const val = src[fromPos];
      const destSel = document.querySelector(`[data-rot="${r}-${destPos}"]`);
      if (!destSel) continue;

      if (!val){
        destSel.value = "";
        continue;
      }

      // rispetto vincolo: niente R/L nelle posizioni di prima linea
      const pl = getPlayer(val);
      if (FRONT_POS.has(destPos) && pl && roleBlockedInFront(pl)){
        destSel.value = "";
        continue;
      }

      // se l'opzione non esiste (id non nel roster), salto
      const hasOpt = Array.from(destSel.options).some(o => o.value === val);
      destSel.value = hasOpt ? val : "";
    }
    enforceNoDuplicates(r);
    updateRotation(r);
  }

  showRuleMsg("R2–R6 impostate ruotando da R1 (R/L esclusi da FS/FC/FD).", "warn");
}

// --- [ADD] ascolto SOLO i cambi delle select di R1 e lancio l’auto-rotazione ---
document.addEventListener("change", (e) => {
  const t = e.target;
  if (t && t.matches('select[data-rot^="1-"]')) {
    autoFillFromR1();
  }
});
</script>
<!-- === [ADD] Auto-propagazione da qualsiasi Rx verso le successive === -->
<script>
// riuso l'ordine già definito in precedenza
const ROT_ORDER = ["FS","FC","FD","SLD","SLC","SLS"];

function rotatePos(pos, shift){
  const n = ROT_ORDER.length;
  const i = ROT_ORDER.indexOf(pos);
  if (i < 0) return pos;
  return ROT_ORDER[(i + (shift % n) + n) % n];
}

function rotationHasValue(r, val){
  return POSITIONS.some(p => {
    const sel = document.querySelector(`[data-rot="${r}-${p}"]`);
    return sel && sel.value === val;
  });
}

// Propaga il valore scelto in Rr,pos verso R(r+1)..R6
function cascadeFrom(rStart, posStart, val){
  if (!val) return;
  for (let r = rStart + 1; r <= 6; r++){
    const shift = (r - rStart);
    const destPos = rotatePos(posStart, shift);
    const destSel = document.querySelector(`[data-rot="${r}-${destPos}"]`);
    if (!destSel) continue;

    // non sovrascrivere scelte già presenti o duplicare nella stessa rotazione
    if (destSel.value) continue;
    if (rotationHasValue(r, val)) continue;

    // rispetto vincolo ruoli R/L in prima linea
    const pl = getPlayer(val);
    if (FRONT_POS.has(destPos) && pl && roleBlockedInFront(pl)) continue;

    // inserisci solo se l'opzione esiste (deve essere nel roster)
    const hasOpt = Array.from(destSel.options).some(o => o.value === val);
    if (!hasOpt) continue;

    destSel.value = val;
    enforceNoDuplicates(r);
    updateRotation(r);
  }
  showRuleMsg(`Propagato da R${rStart} (${posStart}) fino a R6 quando possibile.`, "warn");
}

// Ascolta cambi su TUTTE le select delle rotazioni (tranne R1 che ha già auto-fill)
document.addEventListener("change", (e) => {
  const t = e.target;
  if (!t || !t.matches('select[data-rot]')) return;
  const attr = t.getAttribute('data-rot'); // es. "3-FS"
  const [rStr, pos] = attr.split('-');
  const r = parseInt(rStr, 10);
  if (!r || r <= 1) return; // R1 è gestita dal feature precedente
  const val = t.value;
  cascadeFrom(r, pos, val);
});
</script>
<script>
// === [ADD] Auto-composizione R1: migliori per posizione ===

// Ordine logico di rotazione (già usato altrove)
const ROT_ORDER = ["FS","FC","FD","SLD","SLC","SLS"];

// comparator lessico-decrescente su tuple numeriche
function betterTuple(a, b){
  for (let i=0; i<Math.max(a.length,b.length); i++){
    const av = a[i] ?? -Infinity, bv = b[i] ?? -Infinity;
    if (av > bv) return true;
    if (av < bv) return false;
  }
  return false;
}

// calcola la "tuple score" in base alla posizione
function scoreTupleForPos(p, pos){
  const ATK = Number(p.ATK)||0, BLK = Number(p.BLK)||0, DEF = Number(p.DEF)||0,
        SET = Number(p.SET)||0, SERV = Number(p.SERV)||0;
  switch(pos){
    case "FS": case "FC": case "FD":
      // primarie: ATK+BLK; tie: ATK, poi BLK
      return [ATK+BLK, ATK, BLK];
    case "SLD":
      // primarie: SERV+SET; tie: SERV, poi SET
      return [SERV+SET, SERV, SET];
    case "SLC": case "SLS":
      // primaria: DEF; tie: ATK, poi BLK
      return [DEF, ATK, BLK];
    default:
      return [0];
  }
}

// restituisce i candidati dal roster per quella posizione, filtrando vincoli
function candidatesForPos(pos){
  const entries = rosterEntries();                   // solo gli ID presenti nel roster
  const selR1 = document.querySelector(`[data-rot="1-${pos}"]`);
  if (!selR1) return [];
  return entries
    .map(e => ({ id: e.id, p: getPlayer(e.id) }))
    .filter(x => !!x.p)
    .filter(x => {
      // R/L non ammessi davanti
      if (FRONT_POS.has(pos) && roleBlockedInFront(x.p)) return false;
      // deve esistere l'opzione nella select (nel roster attuale)
      const hasOpt = Array.from(selR1.options).some(o => o.value === x.id);
      return hasOpt;
    })
    .map(x => ({ id: x.id, p: x.p, tup: scoreTupleForPos(x.p, pos) }))
    .sort((a,b) => betterTuple(b.tup, a.tup) ? 1 : betterTuple(a.tup, b.tup) ? -1 : 0);
}

// esegue l’auto-composizione R1 e poi innesca la tua auto-rotazione per R2–R6
function autoComposeR1(){
  const used = new Set();
  for (const pos of ROT_ORDER){
    const sel = document.querySelector(`[data-rot="1-${pos}"]`);
    if (!sel) continue;

    // scegli il primo candidato non ancora usato
    const cand = candidatesForPos(pos).find(c => !used.has(c.id));
    if (cand){
      sel.value = cand.id;
      used.add(cand.id);
    } else {
      sel.value = ""; // se nulla di valido, lascia vuoto
    }
  }
  enforceNoDuplicates(1);
  updateRotation(1);

  // se esiste la funzione di auto-rotazione da R1, richiama per riempire R2–R6
  if (typeof autoFillFromR1 === "function") autoFillFromR1();

  showRuleMsg("R1 auto-composta: migliori stat per posizione (R/L esclusi in FS/FC/FD).", "warn");
}

// UI: aggiungo un pulsante sopra alle rotazioni senza modificare l'HTML originale
(function injectAutoR1Button(){
  const rotations = document.getElementById("rotations");
  if (!rotations) return;
  const bar = document.createElement("div");
  bar.className = "toolbar";
  const btn = document.createElement("button");
  btn.className = "btn";
  btn.textContent = "Auto R1 (migliori stat)";
  btn.addEventListener("click", autoComposeR1);
  bar.appendChild(btn);
  rotations.parentNode.insertBefore(bar, rotations); // inserito subito sopra le rotazioni
})();
</script>
  
<!-- Fallback embedded: incolla qui il tuo players.json per funzionare anche in file:// -->
<script id="players-embedded" type="application/json">
</script>

</body>
</html>



